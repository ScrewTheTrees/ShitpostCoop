"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const Decorator_1 = require("./Decorator");
var ContextType;
(function (ContextType) {
    ContextType[ContextType["None"] = 0] = "None";
    ContextType[ContextType["Void"] = 1] = "Void";
    ContextType[ContextType["NonVoid"] = 2] = "NonVoid";
    ContextType[ContextType["Mixed"] = 3] = "Mixed";
})(ContextType = exports.ContextType || (exports.ContextType = {}));
const defaultArrayCallMethodNames = new Set([
    "concat",
    "push",
    "reverse",
    "shift",
    "unshift",
    "sort",
    "pop",
    "forEach",
    "indexOf",
    "map",
    "filter",
    "some",
    "every",
    "slice",
    "splice",
    "join",
    "flat",
    "flatMap",
]);
class TSHelper {
    static getExtendedTypeNode(node, checker) {
        if (node && node.heritageClauses) {
            for (const clause of node.heritageClauses) {
                if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                    const superType = checker.getTypeAtLocation(clause.types[0]);
                    const decorators = TSHelper.getCustomDecorators(superType, checker);
                    if (!decorators.has(Decorator_1.DecoratorKind.PureAbstract)) {
                        return clause.types[0];
                    }
                }
            }
        }
        return undefined;
    }
    static getExtendedType(node, checker) {
        const extendedTypeNode = TSHelper.getExtendedTypeNode(node, checker);
        return extendedTypeNode && checker.getTypeAtLocation(extendedTypeNode);
    }
    static isFileModule(sourceFile) {
        return sourceFile.statements.some(TSHelper.isStatementExported);
    }
    static isStatementExported(statement) {
        if (ts.isExportAssignment(statement) || ts.isExportDeclaration(statement)) {
            return true;
        }
        if (ts.isVariableStatement(statement)) {
            return statement.declarationList.declarations.some(declaration => (ts.getCombinedModifierFlags(declaration) & ts.ModifierFlags.Export) !== 0);
        }
        return (TSHelper.isDeclaration(statement) &&
            (ts.getCombinedModifierFlags(statement) & ts.ModifierFlags.Export) !== 0);
    }
    static getExportedSymbolDeclaration(symbol) {
        const declarations = symbol.getDeclarations();
        if (declarations) {
            return declarations.find(d => (ts.getCombinedModifierFlags(d) & ts.ModifierFlags.Export) !== 0);
        }
        return undefined;
    }
    static isDeclaration(node) {
        return (ts.isEnumDeclaration(node) ||
            ts.isClassDeclaration(node) ||
            ts.isExportDeclaration(node) ||
            ts.isImportDeclaration(node) ||
            ts.isMethodDeclaration(node) ||
            ts.isModuleDeclaration(node) ||
            ts.isFunctionDeclaration(node) ||
            ts.isVariableDeclaration(node) ||
            ts.isInterfaceDeclaration(node) ||
            ts.isTypeAliasDeclaration(node) ||
            ts.isNamespaceExportDeclaration(node));
    }
    static isInDestructingAssignment(node) {
        return (node.parent &&
            ((ts.isVariableDeclaration(node.parent) && ts.isArrayBindingPattern(node.parent.name)) ||
                (ts.isBinaryExpression(node.parent) && ts.isArrayLiteralExpression(node.parent.left))));
    }
    // iterate over a type and its bases until the callback returns true.
    static forTypeOrAnySupertype(type, checker, predicate) {
        if (predicate(type)) {
            return true;
        }
        if (!type.isClassOrInterface() && type.symbol) {
            type = checker.getDeclaredTypeOfSymbol(type.symbol);
        }
        const superTypes = type.getBaseTypes();
        if (superTypes) {
            for (const superType of superTypes) {
                if (TSHelper.forTypeOrAnySupertype(superType, checker, predicate)) {
                    return true;
                }
            }
        }
        return false;
    }
    static isAmbient(node) {
        return !((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Ambient) === 0);
    }
    static isStatic(node) {
        return node.modifiers !== undefined && node.modifiers.some(m => m.kind === ts.SyntaxKind.StaticKeyword);
    }
    static isStringType(type) {
        return ((type.flags & ts.TypeFlags.String) !== 0 ||
            (type.flags & ts.TypeFlags.StringLike) !== 0 ||
            (type.flags & ts.TypeFlags.StringLiteral) !== 0);
    }
    static isNumberType(type) {
        return ((type.flags & ts.TypeFlags.Number) !== 0 ||
            (type.flags & ts.TypeFlags.NumberLike) !== 0 ||
            (type.flags & ts.TypeFlags.NumberLiteral) !== 0);
    }
    static isExplicitArrayType(type, checker, program) {
        if (type.isUnionOrIntersection()) {
            return type.types.some(t => TSHelper.isExplicitArrayType(t, checker, program));
        }
        if (TSHelper.isStandardLibraryType(type, "ReadonlyArray", program)) {
            return true;
        }
        const flags = ts.NodeBuilderFlags.InTypeAlias | ts.NodeBuilderFlags.AllowEmptyTuple;
        const typeNode = checker.typeToTypeNode(type, undefined, flags);
        return typeNode !== undefined && (ts.isArrayTypeNode(typeNode) || ts.isTupleTypeNode(typeNode));
    }
    static isFunctionType(type, checker) {
        const typeNode = checker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.InTypeAlias);
        return typeNode !== undefined && ts.isFunctionTypeNode(typeNode);
    }
    static isFunctionTypeAtLocation(node, checker) {
        const type = checker.getTypeAtLocation(node);
        return TSHelper.isFunctionType(type, checker);
    }
    static isArrayType(type, checker, program) {
        return TSHelper.forTypeOrAnySupertype(type, checker, t => TSHelper.isExplicitArrayType(t, checker, program));
    }
    static isLuaIteratorType(node, checker) {
        const type = checker.getTypeAtLocation(node);
        return TSHelper.getCustomDecorators(type, checker).has(Decorator_1.DecoratorKind.LuaIterator);
    }
    static isTupleReturnCall(node, checker) {
        if (ts.isCallExpression(node)) {
            const signature = checker.getResolvedSignature(node);
            if (signature) {
                if (TSHelper.getCustomSignatureDirectives(signature, checker).has(Decorator_1.DecoratorKind.TupleReturn)) {
                    return true;
                }
                // Only check function type for directive if it is declared as an interface or type alias
                const declaration = signature.getDeclaration();
                const isInterfaceOrAlias = declaration &&
                    declaration.parent &&
                    ((ts.isInterfaceDeclaration(declaration.parent) && ts.isCallSignatureDeclaration(declaration)) ||
                        ts.isTypeAliasDeclaration(declaration.parent));
                if (!isInterfaceOrAlias) {
                    return false;
                }
            }
            const type = checker.getTypeAtLocation(node.expression);
            return TSHelper.getCustomDecorators(type, checker).has(Decorator_1.DecoratorKind.TupleReturn);
        }
        else {
            return false;
        }
    }
    static isInTupleReturnFunction(node, checker) {
        const declaration = TSHelper.findFirstNodeAbove(node, ts.isFunctionLike);
        if (declaration) {
            let functionType;
            if (ts.isFunctionExpression(declaration) || ts.isArrowFunction(declaration)) {
                functionType = TSHelper.inferAssignedType(declaration, checker);
            }
            else if (ts.isMethodDeclaration(declaration) && ts.isObjectLiteralExpression(declaration.parent)) {
                // Manually lookup type for object literal properties declared with method syntax
                const interfaceType = TSHelper.inferAssignedType(declaration.parent, checker);
                const propertySymbol = interfaceType.getProperty(declaration.name.getText());
                if (propertySymbol) {
                    functionType = checker.getTypeOfSymbolAtLocation(propertySymbol, declaration);
                }
            }
            if (functionType === undefined) {
                functionType = checker.getTypeAtLocation(declaration);
            }
            // Check all overloads for directive
            const signatures = functionType.getCallSignatures();
            if (signatures &&
                signatures.some(s => TSHelper.getCustomSignatureDirectives(s, checker).has(Decorator_1.DecoratorKind.TupleReturn))) {
                return true;
            }
            const decorators = TSHelper.getCustomDecorators(functionType, checker);
            return decorators.has(Decorator_1.DecoratorKind.TupleReturn);
        }
        else {
            return false;
        }
    }
    static getContainingFunctionReturnType(node, checker) {
        const declaration = TSHelper.findFirstNodeAbove(node, ts.isFunctionLike);
        if (declaration) {
            const signature = checker.getSignatureFromDeclaration(declaration);
            return signature === undefined ? undefined : checker.getReturnTypeOfSignature(signature);
        }
        return undefined;
    }
    static collectCustomDecorators(source, checker, decMap) {
        const comments = source.getDocumentationComment(checker);
        const decorators = comments
            .filter(comment => comment.kind === "text")
            .map(comment => comment.text.split("\n"))
            .reduce((a, b) => a.concat(b), [])
            .map(line => line.trim())
            .filter(comment => comment[0] === "!");
        decorators.forEach(decStr => {
            const [decoratorName, ...decoratorArguments] = decStr.split(" ");
            if (Decorator_1.Decorator.isValid(decoratorName.substr(1))) {
                const dec = new Decorator_1.Decorator(decoratorName.substr(1), decoratorArguments);
                decMap.set(dec.kind, dec);
                console.warn(`[Deprecated] Decorators with ! are being deprecated, ` + `use @${decStr.substr(1)} instead`);
            }
            else {
                console.warn(`Encountered unknown decorator ${decStr}.`);
            }
        });
        source.getJsDocTags().forEach(tag => {
            if (Decorator_1.Decorator.isValid(tag.name)) {
                const dec = new Decorator_1.Decorator(tag.name, tag.text ? tag.text.split(" ") : []);
                decMap.set(dec.kind, dec);
            }
        });
    }
    static getCustomDecorators(type, checker) {
        const decMap = new Map();
        if (type.symbol) {
            TSHelper.collectCustomDecorators(type.symbol, checker, decMap);
        }
        if (type.aliasSymbol) {
            TSHelper.collectCustomDecorators(type.aliasSymbol, checker, decMap);
        }
        return decMap;
    }
    static getCustomFileDirectives(file) {
        const decMap = new Map();
        if (file.statements.length > 0) {
            const tags = ts.getJSDocTags(file.statements[0]);
            for (const tag of tags) {
                const tagName = tag.tagName.escapedText;
                if (Decorator_1.Decorator.isValid(tagName)) {
                    const dec = new Decorator_1.Decorator(tagName, tag.comment ? tag.comment.split(" ") : []);
                    decMap.set(dec.kind, dec);
                }
            }
        }
        return decMap;
    }
    static getCustomSignatureDirectives(signature, checker) {
        const directivesMap = new Map();
        TSHelper.collectCustomDecorators(signature, checker, directivesMap);
        // Function properties on interfaces have the JSDoc tags on the parent PropertySignature
        const declaration = signature.getDeclaration();
        if (declaration && declaration.parent && ts.isPropertySignature(declaration.parent)) {
            const symbol = checker.getSymbolAtLocation(declaration.parent.name);
            if (symbol) {
                TSHelper.collectCustomDecorators(symbol, checker, directivesMap);
            }
        }
        return directivesMap;
    }
    // Search up until finding a node satisfying the callback
    static findFirstNodeAbove(node, callback) {
        let current = node;
        while (current.parent) {
            if (callback(current.parent)) {
                return current.parent;
            }
            else {
                current = current.parent;
            }
        }
        return undefined;
    }
    static isBinaryAssignmentToken(token) {
        switch (token) {
            case ts.SyntaxKind.BarEqualsToken:
                return [true, ts.SyntaxKind.BarToken];
            case ts.SyntaxKind.PlusEqualsToken:
                return [true, ts.SyntaxKind.PlusToken];
            case ts.SyntaxKind.CaretEqualsToken:
                return [true, ts.SyntaxKind.CaretToken];
            case ts.SyntaxKind.MinusEqualsToken:
                return [true, ts.SyntaxKind.MinusToken];
            case ts.SyntaxKind.SlashEqualsToken:
                return [true, ts.SyntaxKind.SlashToken];
            case ts.SyntaxKind.PercentEqualsToken:
                return [true, ts.SyntaxKind.PercentToken];
            case ts.SyntaxKind.AsteriskEqualsToken:
                return [true, ts.SyntaxKind.AsteriskToken];
            case ts.SyntaxKind.AmpersandEqualsToken:
                return [true, ts.SyntaxKind.AmpersandToken];
            case ts.SyntaxKind.AsteriskAsteriskEqualsToken:
                return [true, ts.SyntaxKind.AsteriskAsteriskToken];
            case ts.SyntaxKind.LessThanLessThanEqualsToken:
                return [true, ts.SyntaxKind.LessThanLessThanToken];
            case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                return [true, ts.SyntaxKind.GreaterThanGreaterThanToken];
            case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return [true, ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken];
        }
        return [false, undefined];
    }
    // Returns true for expressions that may have effects when evaluated
    static isExpressionWithEvaluationEffect(node) {
        return !(ts.isLiteralExpression(node) || ts.isIdentifier(node) || node.kind === ts.SyntaxKind.ThisKeyword);
    }
    // If expression is property/element access with possible effects from being evaluated, returns true along with the
    // separated object and index expressions.
    static isAccessExpressionWithEvaluationEffects(node, checker, program) {
        if (ts.isElementAccessExpression(node) &&
            (TSHelper.isExpressionWithEvaluationEffect(node.expression) ||
                TSHelper.isExpressionWithEvaluationEffect(node.argumentExpression))) {
            const type = checker.getTypeAtLocation(node.expression);
            if (TSHelper.isArrayType(type, checker, program)) {
                // Offset arrays by one
                const oneLit = ts.createNumericLiteral("1");
                const exp = ts.createParen(node.argumentExpression);
                const addExp = ts.createBinary(exp, ts.SyntaxKind.PlusToken, oneLit);
                return [true, node.expression, addExp];
            }
            else {
                return [true, node.expression, node.argumentExpression];
            }
        }
        else if (ts.isPropertyAccessExpression(node) && TSHelper.isExpressionWithEvaluationEffect(node.expression)) {
            return [true, node.expression, ts.createStringLiteral(node.name.text)];
        }
        return [false, undefined, undefined];
    }
    static isDefaultArrayCallMethodName(methodName) {
        return defaultArrayCallMethodNames.has(methodName);
    }
    static getExplicitThisParameter(signatureDeclaration) {
        return signatureDeclaration.parameters.find(param => ts.isIdentifier(param.name) && param.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword);
    }
    static findInClassOrAncestor(classDeclaration, callback, checker) {
        if (callback(classDeclaration)) {
            return classDeclaration;
        }
        const extendsType = TSHelper.getExtendedType(classDeclaration, checker);
        if (!extendsType) {
            return undefined;
        }
        const symbol = extendsType.getSymbol();
        if (symbol === undefined) {
            return undefined;
        }
        const symbolDeclarations = symbol.getDeclarations();
        if (symbolDeclarations === undefined) {
            return undefined;
        }
        const declaration = symbolDeclarations.find(ts.isClassLike);
        if (!declaration) {
            return undefined;
        }
        return TSHelper.findInClassOrAncestor(declaration, callback, checker);
    }
    static hasSetAccessorInClassOrAncestor(classDeclaration, isStatic, checker) {
        return (TSHelper.findInClassOrAncestor(classDeclaration, c => c.members.some(m => ts.isSetAccessor(m) && TSHelper.isStatic(m) === isStatic), checker) !== undefined);
    }
    static hasGetAccessorInClassOrAncestor(classDeclaration, isStatic, checker) {
        return (TSHelper.findInClassOrAncestor(classDeclaration, c => c.members.some(m => ts.isGetAccessor(m) && TSHelper.isStatic(m) === isStatic), checker) !== undefined);
    }
    static getPropertyName(propertyName) {
        if (ts.isIdentifier(propertyName) || ts.isStringLiteral(propertyName) || ts.isNumericLiteral(propertyName)) {
            return propertyName.text;
        }
        else {
            return undefined; // TODO: how to handle computed property names?
        }
    }
    static isSamePropertyName(a, b) {
        const aName = TSHelper.getPropertyName(a);
        const bName = TSHelper.getPropertyName(b);
        return aName !== undefined && aName === bName;
    }
    static isGetAccessorOverride(element, classDeclaration, checker) {
        if (!ts.isGetAccessor(element) || TSHelper.isStatic(element)) {
            return false;
        }
        const hasInitializedField = (e) => ts.isPropertyDeclaration(e) &&
            e.initializer !== undefined &&
            TSHelper.isSamePropertyName(e.name, element.name);
        return (TSHelper.findInClassOrAncestor(classDeclaration, c => c.members.some(hasInitializedField), checker) !==
            undefined);
    }
    static inferAssignedType(expression, checker) {
        return checker.getContextualType(expression) || checker.getTypeAtLocation(expression);
    }
    static getAllCallSignatures(type) {
        if (type.isUnion()) {
            return type.types.map(t => TSHelper.getAllCallSignatures(t)).reduce((a, b) => a.concat(b));
        }
        return type.getCallSignatures();
    }
    static getSignatureDeclarations(signatures, checker) {
        const signatureDeclarations = [];
        for (const signature of signatures) {
            const signatureDeclaration = signature.getDeclaration();
            if ((ts.isFunctionExpression(signatureDeclaration) || ts.isArrowFunction(signatureDeclaration)) &&
                !TSHelper.getExplicitThisParameter(signatureDeclaration)) {
                // Infer type of function expressions/arrow functions
                const inferredType = TSHelper.inferAssignedType(signatureDeclaration, checker);
                if (inferredType) {
                    const inferredSignatures = TSHelper.getAllCallSignatures(inferredType);
                    if (inferredSignatures.length > 0) {
                        signatureDeclarations.push(...inferredSignatures.map(s => s.getDeclaration()));
                        continue;
                    }
                }
            }
            signatureDeclarations.push(signatureDeclaration);
        }
        return signatureDeclarations;
    }
    static hasNoSelfAncestor(declaration, checker) {
        const scopeDeclaration = TSHelper.findFirstNodeAbove(declaration, (n) => ts.isSourceFile(n) || ts.isModuleDeclaration(n));
        if (!scopeDeclaration) {
            return false;
        }
        if (ts.isSourceFile(scopeDeclaration)) {
            return TSHelper.getCustomFileDirectives(scopeDeclaration).has(Decorator_1.DecoratorKind.NoSelfInFile);
        }
        const scopeType = checker.getTypeAtLocation(scopeDeclaration);
        if (scopeType && TSHelper.getCustomDecorators(scopeType, checker).has(Decorator_1.DecoratorKind.NoSelf)) {
            return true;
        }
        return TSHelper.hasNoSelfAncestor(scopeDeclaration, checker);
    }
    static getDeclarationContextType(signatureDeclaration, checker) {
        const thisParameter = TSHelper.getExplicitThisParameter(signatureDeclaration);
        if (thisParameter) {
            // Explicit 'this'
            return thisParameter.type && thisParameter.type.kind === ts.SyntaxKind.VoidKeyword
                ? ContextType.Void
                : ContextType.NonVoid;
        }
        if (ts.isMethodSignature(signatureDeclaration) ||
            ts.isMethodDeclaration(signatureDeclaration) ||
            ts.isConstructSignatureDeclaration(signatureDeclaration) ||
            ts.isConstructorDeclaration(signatureDeclaration) ||
            (signatureDeclaration.parent && ts.isPropertyDeclaration(signatureDeclaration.parent)) ||
            (signatureDeclaration.parent && ts.isPropertySignature(signatureDeclaration.parent))) {
            // Class/interface methods only respect @noSelf on their parent
            const scopeDeclaration = TSHelper.findFirstNodeAbove(signatureDeclaration, (n) => ts.isClassDeclaration(n) || ts.isClassExpression(n) || ts.isInterfaceDeclaration(n));
            if (scopeDeclaration === undefined) {
                return ContextType.NonVoid;
            }
            const scopeType = checker.getTypeAtLocation(scopeDeclaration);
            if (scopeType && TSHelper.getCustomDecorators(scopeType, checker).has(Decorator_1.DecoratorKind.NoSelf)) {
                return ContextType.Void;
            }
            return ContextType.NonVoid;
        }
        // Walk up to find @noSelf or @noSelfOnFile
        if (TSHelper.hasNoSelfAncestor(signatureDeclaration, checker)) {
            return ContextType.Void;
        }
        return ContextType.NonVoid;
    }
    static reduceContextTypes(contexts) {
        const reducer = (a, b) => {
            if (a === ContextType.None) {
                return b;
            }
            else if (b === ContextType.None) {
                return a;
            }
            else if (a !== b) {
                return ContextType.Mixed;
            }
            else {
                return a;
            }
        };
        return contexts.reduce(reducer, ContextType.None);
    }
    static getFunctionContextType(type, checker) {
        if (type.isTypeParameter()) {
            type = type.getConstraint() || type;
        }
        if (type.isUnion()) {
            return TSHelper.reduceContextTypes(type.types.map(t => TSHelper.getFunctionContextType(t, checker)));
        }
        const signatures = checker.getSignaturesOfType(type, ts.SignatureKind.Call);
        if (signatures.length === 0) {
            return ContextType.None;
        }
        const signatureDeclarations = TSHelper.getSignatureDeclarations(signatures, checker);
        return TSHelper.reduceContextTypes(signatureDeclarations.map(s => TSHelper.getDeclarationContextType(s, checker)));
    }
    static escapeString(text) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String
        const escapeSequences = [
            [/[\\]/g, "\\\\"],
            [/[\']/g, "\\'"],
            [/[\"]/g, '\\"'],
            [/[\n]/g, "\\n"],
            [/[\r]/g, "\\r"],
            [/[\v]/g, "\\v"],
            [/[\t]/g, "\\t"],
            [/[\b]/g, "\\b"],
            [/[\f]/g, "\\f"],
            [/[\0]/g, "\\0"],
        ];
        if (text.length > 0) {
            for (const [regex, replacement] of escapeSequences) {
                text = text.replace(regex, replacement);
            }
        }
        return text;
    }
    static isValidLuaIdentifier(str) {
        const match = str.match(/[a-zA-Z_][a-zA-Z0-9_]*/);
        return match !== undefined && match !== null && match[0] === str;
    }
    static fixInvalidLuaIdentifier(name) {
        return name.replace(/[^a-zA-Z0-9_]/g, c => `_${c
            .charCodeAt(0)
            .toString(16)
            .toUpperCase()}`);
    }
    // Checks that a name is valid for use in lua function declaration syntax:
    // 'foo.bar' => passes ('function foo.bar()' is valid)
    // 'getFoo().bar' => fails ('function getFoo().bar()' would be illegal)
    static isValidLuaFunctionDeclarationName(str) {
        const match = str.match(/[a-zA-Z0-9_\.]+/);
        return match !== undefined && match !== null && match[0] === str;
    }
    static isFalsible(type, strictNullChecks) {
        const falsibleFlags = ts.TypeFlags.Boolean |
            ts.TypeFlags.BooleanLiteral |
            ts.TypeFlags.Undefined |
            ts.TypeFlags.Null |
            ts.TypeFlags.Never |
            ts.TypeFlags.Void |
            ts.TypeFlags.Any;
        if (type.flags & falsibleFlags) {
            return true;
        }
        else if (!strictNullChecks && !type.isLiteral()) {
            return true;
        }
        else if (type.isUnion()) {
            for (const subType of type.types) {
                if (TSHelper.isFalsible(subType, strictNullChecks)) {
                    return true;
                }
            }
        }
        return false;
    }
    static getFirstDeclaration(symbol, sourceFile) {
        let declarations = symbol.getDeclarations();
        if (!declarations) {
            return undefined;
        }
        if (sourceFile) {
            declarations = declarations.filter(d => this.findFirstNodeAbove(d, ts.isSourceFile) === sourceFile);
        }
        return declarations.length > 0 ? declarations.reduce((p, c) => (p.pos < c.pos ? p : c)) : undefined;
    }
    static isFirstDeclaration(node, checker) {
        const symbol = checker.getSymbolAtLocation(node.name);
        if (!symbol) {
            return false;
        }
        const firstDeclaration = this.getFirstDeclaration(symbol);
        return firstDeclaration === node;
    }
    static isStandardLibraryDeclaration(declaration, program) {
        const source = declaration.getSourceFile();
        if (!source) {
            return false;
        }
        return program.isSourceFileDefaultLibrary(source);
    }
    static isStandardLibraryType(type, name, program) {
        const symbol = type.getSymbol();
        if (!symbol || (name ? symbol.escapedName !== name : symbol.escapedName === "__type")) {
            return false;
        }
        const declaration = symbol.valueDeclaration;
        if (!declaration) {
            return true;
        } // assume to be lib function if no valueDeclaration exists
        return this.isStandardLibraryDeclaration(declaration, program);
    }
    static isEnumMember(enumDeclaration, value) {
        if (ts.isIdentifier(value)) {
            const enumMember = enumDeclaration.members.find(m => ts.isIdentifier(m.name) && m.name.text === value.text);
            if (enumMember !== undefined) {
                if (enumMember.initializer && ts.isIdentifier(enumMember.initializer)) {
                    return this.isEnumMember(enumDeclaration, enumMember.initializer);
                }
                else {
                    return [true, enumMember.name];
                }
            }
            else {
                return [false, undefined];
            }
        }
        else {
            return [false, undefined];
        }
    }
    static moduleHasEmittedBody(statement) {
        if (statement.body) {
            if (ts.isModuleBlock(statement.body)) {
                // Ignore if body has no emitted statements
                return (statement.body.statements.findIndex(s => !ts.isInterfaceDeclaration(s) && !ts.isTypeAliasDeclaration(s)) !== -1);
            }
            else if (ts.isModuleDeclaration(statement.body)) {
                return true;
            }
        }
        return false;
    }
    static isArrayLengthAssignment(expression, checker, program) {
        if (expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken) {
            return false;
        }
        if (!ts.isPropertyAccessExpression(expression.left) && !ts.isElementAccessExpression(expression.left)) {
            return false;
        }
        const type = checker.getTypeAtLocation(expression.left.expression);
        if (!TSHelper.isArrayType(type, checker, program)) {
            return false;
        }
        const name = ts.isPropertyAccessExpression(expression.left)
            ? expression.left.name.escapedText
            : ts.isStringLiteral(expression.left.argumentExpression) && expression.left.argumentExpression.text;
        return name === "length";
    }
}
exports.TSHelper = TSHelper;
//# sourceMappingURL=TSHelper.js.map