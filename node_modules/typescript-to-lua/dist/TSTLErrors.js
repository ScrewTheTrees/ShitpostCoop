"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const TranspileError_1 = require("./TranspileError");
const CompilerOptions_1 = require("./CompilerOptions");
const getLuaTargetName = (version) => (version === CompilerOptions_1.LuaTarget.LuaJIT ? "LuaJIT" : `Lua ${version}`);
class TSTLErrors {
}
TSTLErrors.CouldNotCast = (castName) => new Error(`Failed to cast all elements to expected type using ${castName}.`);
TSTLErrors.CouldNotFindEnumMember = (enumDeclaration, enumMember, node) => new TranspileError_1.TranspileError(`Could not find ${enumMember} in ${enumDeclaration.name.text}`, node);
TSTLErrors.DefaultImportsNotSupported = (node) => new TranspileError_1.TranspileError(`Default Imports are not supported, please use named imports instead!`, node);
TSTLErrors.ForbiddenEllipsisDestruction = (node) => new TranspileError_1.TranspileError(`Ellipsis destruction is not allowed.`, node);
TSTLErrors.ForbiddenForIn = (node) => new TranspileError_1.TranspileError(`Iterating over arrays with 'for ... in' is not allowed.`, node);
TSTLErrors.ForbiddenLuaTableSetExpression = (node) => new TranspileError_1.TranspileError(`A '@luaTable' object's 'set()' method can only be used as a Statement, not an Expression.`, node);
TSTLErrors.ForbiddenLuaTableNonDeclaration = (node) => new TranspileError_1.TranspileError(`Classes with the '@luaTable' decorator must be declared.`, node);
TSTLErrors.InvalidExtendsLuaTable = (node) => new TranspileError_1.TranspileError(`Cannot extend classes with the decorator '@luaTable'.`, node);
TSTLErrors.InvalidInstanceOfLuaTable = (node) => new TranspileError_1.TranspileError(`The instanceof operator cannot be used with a '@luaTable' class.`, node);
TSTLErrors.ForbiddenLuaTableUseException = (description, node) => new TranspileError_1.TranspileError(`Invalid @luaTable usage: ${description}`, node);
TSTLErrors.HeterogeneousEnum = (node) => new TranspileError_1.TranspileError(`Invalid heterogeneous enum. Enums should either specify no member values, ` +
    `or specify values (of the same type) for all members.`, node);
TSTLErrors.InvalidDecoratorArgumentNumber = (name, got, expected, node) => new TranspileError_1.TranspileError(`${name} expects ${expected} argument(s) but got ${got}.`, node);
TSTLErrors.InvalidDecoratorContext = (node) => new TranspileError_1.TranspileError(`Decorator function cannot have 'this: void'.`, node);
TSTLErrors.InvalidExtensionMetaExtension = (node) => new TranspileError_1.TranspileError(`Cannot use both '@extension' and '@metaExtension' decorators on the same class.`, node);
TSTLErrors.InvalidNewExpressionOnExtension = (node) => new TranspileError_1.TranspileError(`Cannot construct classes with decorator '@extension' or '@metaExtension'.`, node);
TSTLErrors.InvalidExportDeclaration = (declaration) => new TranspileError_1.TranspileError("Encountered invalid export declaration without exports and without module.", declaration);
TSTLErrors.InvalidExtendsExtension = (node) => new TranspileError_1.TranspileError(`Cannot extend classes with decorator '@extension' or '@metaExtension'.`, node);
TSTLErrors.InvalidExportsExtension = (node) => new TranspileError_1.TranspileError(`Cannot export classes with decorator '@extension' or '@metaExtension'.`, node);
TSTLErrors.InvalidInstanceOfExtension = (node) => new TranspileError_1.TranspileError(`Cannot use instanceof on classes with decorator '@extension' or '@metaExtension'.`, node);
TSTLErrors.InvalidJsonFileContent = (node) => new TranspileError_1.TranspileError("Invalid JSON file content", node);
TSTLErrors.InvalidPropertyCall = (node) => new TranspileError_1.TranspileError(`Tried to transpile a non-property call as property call.`, node);
TSTLErrors.InvalidElementCall = (node) => new TranspileError_1.TranspileError(`Tried to transpile a non-element call as an element call.`, node);
TSTLErrors.InvalidThrowExpression = (node) => new TranspileError_1.TranspileError(`Invalid throw expression, only strings can be thrown.`, node);
TSTLErrors.ForbiddenStaticClassPropertyName = (node, name) => new TranspileError_1.TranspileError(`Cannot use "${name}" as a static class property or method name.`, node);
TSTLErrors.MissingClassName = (node) => new TranspileError_1.TranspileError(`Class declarations must have a name.`, node);
TSTLErrors.MissingForOfVariables = (node) => new TranspileError_1.TranspileError("Transpiled ForOf variable declaration list contains no declarations.", node);
TSTLErrors.MissingFunctionName = (declaration) => new TranspileError_1.TranspileError("Unsupported function declaration without name.", declaration);
TSTLErrors.MissingMetaExtension = (node) => new TranspileError_1.TranspileError(`@metaExtension requires the extension of the metatable class.`, node);
TSTLErrors.MissingSourceFile = () => new Error("Expected transformer.sourceFile to be set, but it isn't.");
TSTLErrors.UndefinedFunctionDefinition = (functionSymbolId) => new Error(`Function definition for function symbol ${functionSymbolId} is undefined.`);
TSTLErrors.UndefinedScope = () => new Error("Expected to pop a scope, but found undefined.");
TSTLErrors.UndefinedTypeNode = (node) => new TranspileError_1.TranspileError("Failed to resolve required type node.", node);
TSTLErrors.UnknownSuperType = (node) => new TranspileError_1.TranspileError("Unable to resolve type of super expression.", node);
TSTLErrors.UnsupportedDefaultExport = (node) => new TranspileError_1.TranspileError(`Default exports are not supported.`, node);
TSTLErrors.UnsupportedImportType = (node) => new TranspileError_1.TranspileError(`Unsupported import type.`, node);
TSTLErrors.UnsupportedKind = (description, kind, node) => new TranspileError_1.TranspileError(`Unsupported ${description} kind: ${ts.SyntaxKind[kind]}`, node);
TSTLErrors.UnsupportedProperty = (parentName, property, node) => new TranspileError_1.TranspileError(`Unsupported property on ${parentName}: ${property}`, node);
TSTLErrors.UnsupportedForTarget = (functionality, version, node) => new TranspileError_1.TranspileError(`${functionality} is/are not supported for target ${getLuaTargetName(version)}.`, node);
TSTLErrors.UnsupportedFunctionWithoutBody = (node) => new TranspileError_1.TranspileError("Functions with undefined bodies are not supported.", node);
TSTLErrors.UnsupportedNoSelfFunctionConversion = (node, name) => {
    if (name) {
        return new TranspileError_1.TranspileError(`Unable to convert function with a 'this' parameter to function "${name}" with no 'this'. ` +
            `To fix, wrap in an arrow function, or declare with 'this: void'.`, node);
    }
    else {
        return new TranspileError_1.TranspileError(`Unable to convert function with a 'this' parameter to function with no 'this'. ` +
            `To fix, wrap in an arrow function, or declare with 'this: void'.`, node);
    }
};
TSTLErrors.UnsupportedSelfFunctionConversion = (node, name) => {
    if (name) {
        return new TranspileError_1.TranspileError(`Unable to convert function with no 'this' parameter to function "${name}" with 'this'. ` +
            `To fix, wrap in an arrow function or declare with 'this: any'.`, node);
    }
    else {
        return new TranspileError_1.TranspileError(`Unable to convert function with no 'this' parameter to function with 'this'. ` +
            `To fix, wrap in an arrow function or declare with 'this: any'.`, node);
    }
};
TSTLErrors.UnsupportedOverloadAssignment = (node, name) => {
    if (name) {
        return new TranspileError_1.TranspileError(`Unsupported assignment of function with different overloaded types for 'this' to "${name}". ` +
            `Overloads should all have the same type for 'this'.`, node);
    }
    else {
        return new TranspileError_1.TranspileError(`Unsupported assignment of function with different overloaded types for 'this'. ` +
            `Overloads should all have the same type for 'this'.`, node);
    }
};
TSTLErrors.UnsupportedNonDestructuringLuaIterator = (node) => {
    return new TranspileError_1.TranspileError("Unsupported use of lua iterator with TupleReturn decorator in for...of statement. " +
        "You must use a destructuring statement to catch results from a lua iterator with " +
        "the TupleReturn decorator.", node);
};
TSTLErrors.UnresolvableRequirePath = (node, reason, path) => {
    return new TranspileError_1.TranspileError(`${reason}. ` + `TypeScript path: ${path}.`, node);
};
TSTLErrors.ReferencedBeforeDeclaration = (node) => {
    return new TranspileError_1.TranspileError(`Identifier "${node.text}" was referenced before it was declared. The declaration ` +
        "must be moved before the identifier's use, or hoisting must be enabled.", node);
};
TSTLErrors.UnsupportedObjectDestructuringInForOf = (node) => {
    return new TranspileError_1.TranspileError(`Unsupported object destructuring in for...of statement.`, node);
};
TSTLErrors.InvalidAmbientIdentifierName = (node) => {
    return new TranspileError_1.TranspileError(`Invalid ambient identifier name "${node.text}". Ambient identifiers must be valid lua identifiers.`, node);
};
exports.TSTLErrors = TSTLErrors;
//# sourceMappingURL=TSTLErrors.js.map