import * as ts from "typescript";
import { Decorator, DecoratorKind } from "./Decorator";
export declare enum ContextType {
    None = 0,
    Void = 1,
    NonVoid = 2,
    Mixed = 3
}
export declare class TSHelper {
    static getExtendedTypeNode(node: ts.ClassLikeDeclarationBase, checker: ts.TypeChecker): ts.ExpressionWithTypeArguments | undefined;
    static getExtendedType(node: ts.ClassLikeDeclarationBase, checker: ts.TypeChecker): ts.Type | undefined;
    static isFileModule(sourceFile: ts.SourceFile): boolean;
    static isStatementExported(statement: ts.Statement): boolean;
    static getExportedSymbolDeclaration(symbol: ts.Symbol): ts.Declaration | undefined;
    static isDeclaration(node: ts.Node): node is ts.Declaration;
    static isInDestructingAssignment(node: ts.Node): boolean;
    static forTypeOrAnySupertype(type: ts.Type, checker: ts.TypeChecker, predicate: (type: ts.Type) => boolean): boolean;
    static isAmbient(node: ts.Declaration): boolean;
    static isStatic(node: ts.Node): boolean;
    static isStringType(type: ts.Type): boolean;
    static isNumberType(type: ts.Type): boolean;
    static isExplicitArrayType(type: ts.Type, checker: ts.TypeChecker, program: ts.Program): boolean;
    static isFunctionType(type: ts.Type, checker: ts.TypeChecker): boolean;
    static isFunctionTypeAtLocation(node: ts.Node, checker: ts.TypeChecker): boolean;
    static isArrayType(type: ts.Type, checker: ts.TypeChecker, program: ts.Program): boolean;
    static isLuaIteratorType(node: ts.Node, checker: ts.TypeChecker): boolean;
    static isTupleReturnCall(node: ts.Node, checker: ts.TypeChecker): boolean;
    static isInTupleReturnFunction(node: ts.Node, checker: ts.TypeChecker): boolean;
    static getContainingFunctionReturnType(node: ts.Node, checker: ts.TypeChecker): ts.Type | undefined;
    static collectCustomDecorators(source: ts.Symbol | ts.Signature, checker: ts.TypeChecker, decMap: Map<DecoratorKind, Decorator>): void;
    static getCustomDecorators(type: ts.Type, checker: ts.TypeChecker): Map<DecoratorKind, Decorator>;
    static getCustomFileDirectives(file: ts.SourceFile): Map<DecoratorKind, Decorator>;
    static getCustomSignatureDirectives(signature: ts.Signature, checker: ts.TypeChecker): Map<DecoratorKind, Decorator>;
    static findFirstNodeAbove<T extends ts.Node>(node: ts.Node, callback: (n: ts.Node) => n is T): T | undefined;
    static isBinaryAssignmentToken(token: ts.SyntaxKind): [true, ts.BinaryOperator] | [false, undefined];
    static isExpressionWithEvaluationEffect(node: ts.Expression): boolean;
    static isAccessExpressionWithEvaluationEffects(node: ts.Expression, checker: ts.TypeChecker, program: ts.Program): [true, ts.Expression, ts.Expression] | [false, undefined, undefined];
    static isDefaultArrayCallMethodName(methodName: string): boolean;
    static getExplicitThisParameter(signatureDeclaration: ts.SignatureDeclaration): ts.ParameterDeclaration | undefined;
    static findInClassOrAncestor(classDeclaration: ts.ClassLikeDeclarationBase, callback: (classDeclaration: ts.ClassLikeDeclarationBase) => boolean, checker: ts.TypeChecker): ts.ClassLikeDeclarationBase | undefined;
    static hasSetAccessorInClassOrAncestor(classDeclaration: ts.ClassLikeDeclarationBase, isStatic: boolean, checker: ts.TypeChecker): boolean;
    static hasGetAccessorInClassOrAncestor(classDeclaration: ts.ClassLikeDeclarationBase, isStatic: boolean, checker: ts.TypeChecker): boolean;
    static getPropertyName(propertyName: ts.PropertyName): string | number | undefined;
    static isSamePropertyName(a: ts.PropertyName, b: ts.PropertyName): boolean;
    static isGetAccessorOverride(element: ts.ClassElement, classDeclaration: ts.ClassLikeDeclarationBase, checker: ts.TypeChecker): element is ts.GetAccessorDeclaration;
    static inferAssignedType(expression: ts.Expression, checker: ts.TypeChecker): ts.Type;
    static getAllCallSignatures(type: ts.Type): ReadonlyArray<ts.Signature>;
    static getSignatureDeclarations(signatures: readonly ts.Signature[], checker: ts.TypeChecker): ts.SignatureDeclaration[];
    static hasNoSelfAncestor(declaration: ts.Declaration, checker: ts.TypeChecker): boolean;
    static getDeclarationContextType(signatureDeclaration: ts.SignatureDeclaration, checker: ts.TypeChecker): ContextType;
    static reduceContextTypes(contexts: ContextType[]): ContextType;
    static getFunctionContextType(type: ts.Type, checker: ts.TypeChecker): ContextType;
    static escapeString(text: string): string;
    static isValidLuaIdentifier(str: string): boolean;
    static fixInvalidLuaIdentifier(name: string): string;
    static isValidLuaFunctionDeclarationName(str: string): boolean;
    static isFalsible(type: ts.Type, strictNullChecks: boolean): boolean;
    static getFirstDeclaration(symbol: ts.Symbol, sourceFile?: ts.SourceFile): ts.Declaration | undefined;
    static isFirstDeclaration(node: ts.VariableDeclaration, checker: ts.TypeChecker): boolean;
    static isStandardLibraryDeclaration(declaration: ts.Declaration, program: ts.Program): boolean;
    static isStandardLibraryType(type: ts.Type, name: string | undefined, program: ts.Program): boolean;
    static isEnumMember(enumDeclaration: ts.EnumDeclaration, value: ts.Expression): [true, ts.PropertyName] | [false, undefined];
    static moduleHasEmittedBody(statement: ts.ModuleDeclaration): statement is ts.ModuleDeclaration & {
        body: ts.ModuleBlock | ts.ModuleDeclaration;
    };
    static isArrayLengthAssignment(expression: ts.BinaryExpression, checker: ts.TypeChecker, program: ts.Program): expression is ts.BinaryExpression & {
        left: ts.PropertyAccessExpression | ts.ElementAccessExpression;
    };
}
