import * as ts from "typescript";
import { CompilerOptions } from "./CompilerOptions";
import * as tstl from "./LuaAST";
import { LuaLibFeature } from "./LuaLib";
export declare type StatementVisitResult = tstl.Statement | tstl.Statement[] | undefined;
export declare type ExpressionVisitResult = tstl.Expression;
export declare enum ScopeType {
    File = 1,
    Function = 2,
    Switch = 4,
    Loop = 8,
    Conditional = 16,
    Block = 32
}
interface FunctionDefinitionInfo {
    referencedSymbols: Set<tstl.SymbolId>;
    definition?: tstl.VariableDeclarationStatement | tstl.AssignmentStatement;
}
interface Scope {
    type: ScopeType;
    id: number;
    referencedSymbols?: Set<tstl.SymbolId>;
    variableDeclarations?: tstl.VariableDeclarationStatement[];
    functionDefinitions?: Map<tstl.SymbolId, FunctionDefinitionInfo>;
    importStatements?: tstl.Statement[];
    loopContinued?: boolean;
}
export interface EmitResolver {
    isValueAliasDeclaration(node: ts.Node): boolean;
    isReferencedAliasDeclaration(node: ts.Node, checkChildren?: boolean): boolean;
    isTopLevelValueImportEqualsWithEntityName(node: ts.ImportEqualsDeclaration): boolean;
    moduleExportsSomeValue(moduleReferenceExpression: ts.Expression): boolean;
}
export interface DiagnosticsProducingTypeChecker extends ts.TypeChecker {
    getEmitResolver(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken): EmitResolver;
}
export declare class LuaTransformer {
    protected program: ts.Program;
    private isStrict;
    private luaTarget;
    private checker;
    protected options: CompilerOptions;
    private resolver;
    private isModule;
    private currentSourceFile?;
    private currentNamespace;
    private classStack;
    private scopeStack;
    private genVarCounter;
    private luaLibFeatureSet;
    private symbolInfo;
    private symbolIds;
    private genSymbolIdCounter;
    private readonly typeValidationCache;
    constructor(program: ts.Program);
    private setupState;
    transformSourceFile(node: ts.SourceFile): [tstl.Block, Set<LuaLibFeature>];
    transformStatement(node: ts.Statement): StatementVisitResult;
    /** Converts an array of ts.Statements into an array of tstl.Statements */
    private transformStatements;
    transformBlock(block: ts.Block): tstl.Block;
    transformBlockAsDoStatement(block: ts.Block): StatementVisitResult;
    transformExportDeclaration(statement: ts.ExportDeclaration): StatementVisitResult;
    transformImportDeclaration(statement: ts.ImportDeclaration): StatementVisitResult;
    private createModuleRequire;
    private validateClassElement;
    transformImportEqualsDeclaration(declaration: ts.ImportEqualsDeclaration): StatementVisitResult;
    transformExternalModuleReference(externalModuleReference: ts.ExternalModuleReference): ExpressionVisitResult;
    private transformEntityName;
    transformQualifiedName(qualifiedName: ts.QualifiedName): ExpressionVisitResult;
    transformClassDeclaration(statement: ts.ClassLikeDeclaration, nameOverride?: tstl.Identifier): StatementVisitResult;
    private createClassCreationMethods;
    private transformClassInstanceFields;
    private createConstructorName;
    private transformConstructorDeclaration;
    transformGetAccessorDeclaration(getAccessor: ts.GetAccessorDeclaration, className: tstl.Identifier): StatementVisitResult;
    transformSetAccessorDeclaration(setAccessor: ts.SetAccessorDeclaration, className: tstl.Identifier): StatementVisitResult;
    transformMethodDeclaration(node: ts.MethodDeclaration, className: tstl.Identifier, noPrototype: boolean): StatementVisitResult;
    private transformParameters;
    private transformFunctionBody;
    private transformParameterDefaultValueDeclaration;
    transformBindingPattern(pattern: ts.BindingPattern, table: tstl.Identifier, propertyAccessStack?: ts.PropertyName[]): StatementVisitResult;
    protected createModuleLocalNameIdentifier(declaration: ts.ModuleDeclaration): tstl.Identifier;
    transformModuleDeclaration(statement: ts.ModuleDeclaration): StatementVisitResult;
    transformEnumDeclaration(enumDeclaration: ts.EnumDeclaration): StatementVisitResult;
    protected computeEnumMembers(node: ts.EnumDeclaration): Array<{
        name: ts.PropertyName;
        value: tstl.Expression;
        original: ts.Node;
    }>;
    private transformGeneratorFunction;
    transformFunctionDeclaration(functionDeclaration: ts.FunctionDeclaration): StatementVisitResult;
    transformTypeAliasDeclaration(_statement: ts.TypeAliasDeclaration): StatementVisitResult;
    transformInterfaceDeclaration(_statement: ts.InterfaceDeclaration): StatementVisitResult;
    transformVariableDeclaration(statement: ts.VariableDeclaration): StatementVisitResult;
    transformVariableStatement(statement: ts.VariableStatement): StatementVisitResult;
    transformExpressionStatement(statement: ts.ExpressionStatement | ts.Expression): StatementVisitResult;
    transformYieldExpression(expression: ts.YieldExpression): ExpressionVisitResult;
    transformReturnStatement(statement: ts.ReturnStatement): StatementVisitResult;
    transformIfStatement(statement: ts.IfStatement): StatementVisitResult;
    transformWhileStatement(statement: ts.WhileStatement): StatementVisitResult;
    transformDoStatement(statement: ts.DoStatement): StatementVisitResult;
    transformForStatement(statement: ts.ForStatement): StatementVisitResult;
    private transformForOfInitializer;
    protected transformLoopBody(loop: ts.WhileStatement | ts.DoStatement | ts.ForStatement | ts.ForOfStatement | ts.ForInOrOfStatement): tstl.Statement[];
    private transformBlockOrStatement;
    private transformForOfArrayStatement;
    private transformForOfLuaIteratorStatement;
    private transformForOfIteratorStatement;
    transformForOfStatement(statement: ts.ForOfStatement): StatementVisitResult;
    transformForInStatement(statement: ts.ForInStatement): StatementVisitResult;
    transformSwitchStatement(statement: ts.SwitchStatement): StatementVisitResult;
    transformBreakStatement(breakStatement: ts.BreakStatement): StatementVisitResult;
    transformTryStatement(statement: ts.TryStatement): StatementVisitResult;
    transformThrowStatement(statement: ts.ThrowStatement): StatementVisitResult;
    transformContinueStatement(statement: ts.ContinueStatement): StatementVisitResult;
    transformEmptyStatement(_statement: ts.EmptyStatement): StatementVisitResult;
    transformExpression(expression: ts.Expression): ExpressionVisitResult;
    protected transformBinaryOperation(left: tstl.Expression, right: tstl.Expression, operator: ts.BinaryOperator, tsOriginal: ts.Node): ExpressionVisitResult;
    transformBinaryExpression(expression: ts.BinaryExpression): ExpressionVisitResult;
    private transformAssignment;
    private transformAssignmentStatement;
    private transformAssignmentExpression;
    private transformCompoundAssignmentExpression;
    transformBinaryOperator(operator: ts.BinaryOperator, node: ts.Node): tstl.BinaryOperator;
    transformClassExpression(expression: ts.ClassExpression): ExpressionVisitResult;
    private transformCompoundAssignmentStatement;
    private transformUnaryBitLibOperation;
    private transformUnaryBitOperation;
    private transformBinaryBitLibOperation;
    private transformBinaryBitOperation;
    private transformProtectedConditionalExpression;
    transformConditionalExpression(expression: ts.ConditionalExpression): ExpressionVisitResult;
    transformPostfixUnaryExpression(expression: ts.PostfixUnaryExpression): ExpressionVisitResult;
    transformPrefixUnaryExpression(expression: ts.PrefixUnaryExpression): ExpressionVisitResult;
    transformArrayLiteral(expression: ts.ArrayLiteralExpression): ExpressionVisitResult;
    transformObjectLiteral(expression: ts.ObjectLiteralExpression): ExpressionVisitResult;
    transformDeleteExpression(expression: ts.DeleteExpression): ExpressionVisitResult;
    transformFunctionExpression(node: ts.FunctionLikeDeclaration): ExpressionVisitResult;
    transformNewExpression(node: ts.NewExpression): ExpressionVisitResult;
    transformParenthesizedExpression(expression: ts.ParenthesizedExpression): ExpressionVisitResult;
    transformSuperKeyword(expression: ts.SuperExpression): ExpressionVisitResult;
    transformCallExpression(expression: ts.CallExpression): ExpressionVisitResult;
    private transformGlobalFunctionCall;
    transformPropertyCall(node: ts.CallExpression): ExpressionVisitResult;
    transformElementCall(node: ts.CallExpression): ExpressionVisitResult;
    private transformArguments;
    transformPropertyAccessExpression(expression: ts.PropertyAccessExpression): ExpressionVisitResult;
    private transformMathExpression;
    private transformMathCallExpression;
    private transformStringProperty;
    private transformArrayProperty;
    private transformLuaTableProperty;
    transformElementAccessExpression(expression: ts.ElementAccessExpression): ExpressionVisitResult;
    private transformConstEnumValue;
    private transformStringCallExpression;
    private createStringCall;
    private transformStringExpression;
    private transformObjectCallExpression;
    private transformConsoleCallExpression;
    private isStringFormatTemplate;
    private transformSymbolCallExpression;
    private transformNumberCallExpression;
    private validateLuaTableCall;
    private transformLuaTableExpressionStatement;
    private transformLuaTableCallExpression;
    private transformArrayCallExpression;
    private transformFunctionCallExpression;
    transformArrayBindingElement(name: ts.ArrayBindingElement): ExpressionVisitResult;
    transformAssertionExpression(expression: ts.AssertionExpression): ExpressionVisitResult;
    transformTypeOfExpression(expression: ts.TypeOfExpression): ExpressionVisitResult;
    transformSpreadElement(expression: ts.SpreadElement): ExpressionVisitResult;
    transformStringLiteral(literal: ts.StringLiteralLike): ExpressionVisitResult;
    transformNumericLiteral(literal: ts.NumericLiteral): ExpressionVisitResult;
    transformTrueKeyword(trueKeyword: ts.BooleanLiteral): ExpressionVisitResult;
    transformFalseKeyword(falseKeyword: ts.BooleanLiteral): ExpressionVisitResult;
    transformNullOrUndefinedKeyword(originalNode: ts.Node): ExpressionVisitResult;
    transformThisKeyword(thisKeyword: ts.ThisExpression): ExpressionVisitResult;
    transformTemplateExpression(expression: ts.TemplateExpression): ExpressionVisitResult;
    transformPropertyName(propertyName: ts.PropertyName): ExpressionVisitResult;
    protected getIdentifierText(identifier: ts.Identifier): string;
    transformIdentifier(identifier: ts.Identifier): tstl.Identifier;
    private transformIdentifierExpression;
    protected getSymbolFromIdentifier(identifier: tstl.Identifier): ts.Symbol | undefined;
    protected getIdentifierExportScope(identifier: tstl.Identifier): ts.SourceFile | ts.ModuleDeclaration | undefined;
    protected isSymbolExported(symbol: ts.Symbol): boolean;
    protected isSymbolExportedFromScope(symbol: ts.Symbol, scope: ts.SourceFile | ts.ModuleDeclaration): boolean;
    protected addExportToIdentifier(identifier: tstl.Identifier): tstl.AssignmentLeftHandSideExpression;
    protected createExportedIdentifier(identifier: tstl.Identifier, exportScope?: ts.SourceFile | ts.ModuleDeclaration): tstl.AssignmentLeftHandSideExpression;
    protected getSymbolExportScope(symbol: ts.Symbol): ts.SourceFile | ts.ModuleDeclaration | undefined;
    protected transformLuaLibFunction(func: LuaLibFeature, tsParent?: ts.Expression, ...params: tstl.Expression[]): tstl.CallExpression;
    protected checkForLuaLibType(type: ts.Type): void;
    protected importLuaLibFeature(feature: LuaLibFeature): void;
    protected createImmediatelyInvokedFunctionExpression(statements: tstl.Statement[], result: tstl.Expression | tstl.Expression[], tsOriginal: ts.Node): tstl.CallExpression;
    protected createUnpackCall(expression: tstl.Expression | undefined, tsOriginal: ts.Node): tstl.Expression;
    protected getAbsoluteImportPath(relativePath: string): string;
    protected getImportPath(relativePath: string, node: ts.Node): string;
    protected formatPathToLuaPath(filePath: string): string;
    protected createSelfIdentifier(tsOriginal?: ts.Node): tstl.Identifier;
    protected createExportsIdentifier(): tstl.Identifier;
    protected createLocalOrExportedOrGlobalDeclaration(lhs: tstl.Identifier | tstl.Identifier[], rhs?: tstl.Expression | tstl.Expression[], tsOriginal?: ts.Node, parent?: tstl.Node): tstl.Statement[];
    protected validateFunctionAssignment(node: ts.Node, fromType: ts.Type, toType: ts.Type, toName?: string): void;
    protected validatePropertyAssignment(node: ts.Node): void;
    protected wrapInFunctionCall(expression: tstl.Expression): tstl.FunctionExpression;
    protected wrapInTable(...expressions: tstl.Expression[]): tstl.ParenthesizedExpression;
    protected wrapInToStringForConcat(expression: tstl.Expression): tstl.Expression;
    protected expressionPlusOne(expression: tstl.Expression): tstl.Expression;
    protected createShorthandIdentifier(valueSymbol: ts.Symbol | undefined, propertyIdentifier: ts.Identifier): tstl.Expression;
    protected isUnsafeName(name: string): boolean;
    protected hasUnsafeSymbolName(symbol: ts.Symbol, tsOriginal?: ts.Identifier): boolean;
    protected hasUnsafeIdentifierName(identifier: ts.Identifier): boolean;
    protected createSafeName(name: string): string;
    protected getIdentifierSymbolId(identifier: ts.Identifier): tstl.SymbolId | undefined;
    protected findScope(scopeTypes: ScopeType): Scope | undefined;
    protected peekScope(): Scope | undefined;
    protected pushScope(scopeType: ScopeType): void;
    private shouldHoist;
    protected replaceStatementInParent(oldNode: tstl.Statement, newNode?: tstl.Statement): void;
    protected hoistImportStatements(scope: Scope, statements: tstl.Statement[]): tstl.Statement[];
    protected hoistFunctionDefinitions(scope: Scope, statements: tstl.Statement[]): tstl.Statement[];
    protected hoistVariableDeclarations(scope: Scope, statements: tstl.Statement[]): tstl.Statement[];
    protected performHoisting(statements: tstl.Statement[]): tstl.Statement[];
    protected popScope(): Scope;
    protected createHoistableVariableDeclarationStatement(identifier: tstl.Identifier, initializer?: tstl.Expression, tsOriginal?: ts.Node, parent?: tstl.Node): tstl.AssignmentStatement | tstl.VariableDeclarationStatement;
    protected statementVisitResultToArray(visitResult: StatementVisitResult): tstl.Statement[];
    protected filterUndefined<T>(items: Array<T | undefined>): T[];
    protected filterUndefinedAndCast<TOriginal, TCast extends TOriginal>(items: Array<TOriginal | undefined>, cast: (item: TOriginal) => item is TCast): TCast[];
    private createConstructorDecorationStatement;
}
export {};
